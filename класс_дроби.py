# -*- coding: utf-8 -*-
"""класс_дроби.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15et2Xn0Stv0s0cvSWzaEgttShCTczYuu
"""

class Rational:
    def __init__(self, num, denum):
        assert denum != 0, "Знаменатель не может быть равен нулю"
        if denum < 0:
            num *= -1
            denum *= -1
        self.num = num
        self.denum = denum
        self._reduce()

    def _reduce(self):
        gcd = self._gcd(abs(self.num), abs(self.denum))
        self.num //= gcd
        self.denum //= gcd
        if self.denum < 0:
            self.num *= -1
            self.denum *= -1

    @staticmethod
    def _gcd(a, b):
        while b != 0:
            a, b = b, a % b
        return a

    def __add__(self, rhs):
        if isinstance(rhs, int):
            return Rational(self.num + rhs * self.denum, self.denum)
        if isinstance(rhs, Rational):
            return Rational(self.num * rhs.denum + rhs.num * self.denum,
                        self.denum * rhs.denum)
        raise TypeError(f"Неподдерживаемый тип: {type(rhs)}")

    def __radd__(self, lhs):
        return self.__add__(lhs)

    def __sub__(self, rhs):
        if isinstance(rhs, int):
            return Rational(self.num - rhs * self.denum, self.denum)
        if isinstance(rhs, Rational):
            return Rational(self.num * rhs.denum - rhs.num * self.denum,
                        self.denum * rhs.denum)
        raise TypeError(f"Неподдерживаемый тип: {type(rhs)}")

    def __rsub__(self, lhs):
        if isinstance(lhs, int):
            return Rational(lhs * self.denum - self.num, self.denum)
        raise TypeError(f"Неподдерживаемый тип: {type(lhs)}")

    def __mul__(self, rhs):
        if isinstance(rhs, int):
            return Rational(self.num * rhs, self.denum)
        if isinstance(rhs, Rational):
            return Rational(self.num * rhs.num, self.denum * rhs.denum)
        raise TypeError(f"Неподдерживаемый тип: {type(rhs)}")

    def __rmul__(self, lhs):
        return self.__mul__(lhs)

    def __truediv__(self, rhs):
        if isinstance(rhs, int):
            if rhs == 0:
                raise ZeroDivisionError("Деление на ноль")
            return Rational(self.num, self.denum * rhs)
        if isinstance(rhs, Rational):
            if rhs.num == 0:
                raise ZeroDivisionError("Деление на ноль")
            return Rational(self.num * rhs.denum, self.denum * rhs.num)
        raise TypeError(f"Неподдерживаемый тип: {type(rhs)}")

    def __rtruediv__(self, lhs):
        if isinstance(lhs, int):
            if self.num == 0:
                raise ZeroDivisionError("Деление на ноль")
            return Rational(lhs * self.denum, self.num)
        raise TypeError(f"Неподдерживаемый тип: {type(lhs)}")

    def __eq__(self, rhs):
        if isinstance(rhs, int):
            return self.num == rhs * self.denum
        if isinstance(rhs, Rational):
            return self.num * rhs.denum == rhs.num * self.denum
        return False

    def __ne__(self, rhs):
        return not self.__eq__(rhs)

    def __lt__(self, rhs):
        if isinstance(rhs, int):
            return self.num < rhs * self.denum
        if isinstance(rhs, Rational):
            return self.num * rhs.denum < rhs.num * self.denum
        raise TypeError(f"Неподдерживаемый тип: {type(rhs)}")

    def __le__(self, rhs):
        if isinstance(rhs, int):
            return self.num <= rhs * self.denum
        if isinstance(rhs, Rational):
            return self.num * rhs.denum <= rhs.num * self.denum
        raise TypeError(f"Неподдерживаемый тип: {type(rhs)}")

    def __gt__(self, rhs):
        if isinstance(rhs, int):
            return self.num > rhs * self.denum
        if isinstance(rhs, Rational):
            return self.num * rhs.denum > rhs.num * self.denum
        raise TypeError(f"Неподдерживаемый тип: {type(rhs)}")

    def __ge__(self, rhs):
        if isinstance(rhs, int):
            return self.num >= rhs * self.denum
        if isinstance(rhs, Rational):
            return self.num * rhs.denum >= rhs.num * self.denum
        raise TypeError(f"Неподдерживаемый тип: {type(rhs)}")

    def __neg__(self):
        return Rational(-self.num, self.denum)

    def __str__(self):
        return f"{self.num}/{self.denum}"

    def __repr__(self):
        return f"Rational({self.num}, {self.denum})"


#Примеры использования и тестирования
if __name__ == "__main__":
    try:
        #Тестирование создания дробей
        r1 = Rational(1, 2)
        r2 = Rational(2, 4)  #Сократится до 1/2
        r3 = Rational(3, 4)

        print(f"r1 = {r1}")
        print(f"r2 = {r2}")
        print(f"r3 = {r3}")

        #Тестирование операций
        print(f"\nСложение: {r1} + {r3} = {r1 + r3}")
        print(f"Вычитание: {r3} - {r1} = {r3 - r1}")
        print(f"Умножение: {r1} * {r3} = {r1 * r3}")
        print(f"Деление: {r3} / {r1} = {r3 / r1}")

        #Тестирование с целыми числами
        print(f"\nС целыми числами:")
        print(f"2 + {r1} = {2 + r1}")
        print(f"{r1} + 2 = {r1 + 2}")
        print(f"2 * {r1} = {2 * r1}")
        print(f"{r1} * 2 = {r1 * 2}")

        #Тестирование сравнения
        print(f"\nСравнение:")
        print(f"{r1} == {r2}: {r1 == r2}")
        print(f"{r1} == 0.5: {r1 == 0.5}")  #Сравнение с float, должно вернуть False
        print(f"{r1} < {r3}: {r1 < r3}")
        print(f"{r3} > {r1}: {r3 > r1}")

        #Тестирование исключений
        print(f"\nТестирование исключений:")
        try:
            bad_rational = Rational(1, 0)
        except AssertionError as e:
            print(f"Ошибка при создании: {e}")

        try:
            division_by_zero = r1 / 0
        except ZeroDivisionError as e:
            print(f"Ошибка деления на ноль: {e}")

        try:
            division_by_zero_rational = r1 / Rational(0, 1)
        except ZeroDivisionError as e:
            print(f"Ошибка деления на нулевую дробь: {e}")

    except Exception as e:
        print(f"Произошла ошибка: {e}")

